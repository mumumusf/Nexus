#!/bin/bash

# Nexus Network 一体化管理工具
# 作者: @YOYOMYOYOA
# 版本: v4.2.0

# 全局变量
SESSION_MANAGER=""
USE_CONTAINER="false"

# 环境检测函数
detect_environment() {
    # 检测是否在WSL环境中
    if grep -qi microsoft /proc/version 2>/dev/null; then
        ENVIRONMENT="WSL"
        echo "🔍 检测到 Windows WSL 环境"
        SESSION_MANAGER="tmux"
        echo "🛠️ WSL环境将使用 tmux 管理会话"
    elif [[ -f /proc/version ]]; then
        ENVIRONMENT="LINUX"
        echo "🔍 检测到 Linux 环境"
        SESSION_MANAGER="screen"
        echo "🛠️ Linux环境将使用 screen 管理会话"
    else
        ENVIRONMENT="UNKNOWN"
        echo "⚠️ 未知环境，将按Linux方式运行"
        SESSION_MANAGER="screen"
    fi
    
    # 检测发行版
    if command -v lsb_release >/dev/null 2>&1; then
        DISTRO=$(lsb_release -si 2>/dev/null)
    elif [[ -f /etc/os-release ]]; then
        DISTRO=$(grep '^ID=' /etc/os-release | cut -d= -f2 | tr -d '"')
    else
        DISTRO="unknown"
    fi
    
    echo "💻 环境信息: $ENVIRONMENT ($DISTRO)"
    echo "📱 会话管理器: $SESSION_MANAGER"
    echo ""
}

# 检测Docker是否可用
check_docker() {
    if command -v docker >/dev/null 2>&1; then
        if docker info >/dev/null 2>&1; then
            echo "🐳 Docker 可用"
            return 0
        else
            echo "⚠️ Docker 已安装但无法连接到守护进程"
            return 1
        fi
    else
        echo "❌ Docker 未安装"
        return 1
    fi
}

# 安装Docker
install_docker() {
    echo "🐳 安装 Docker..."
    
    PKG_MANAGER=$(get_package_manager)
    
    case $PKG_MANAGER in
        "apt")
            echo "🔄 更新软件包列表..."
            $SUDO_CMD apt update
            
            echo "📦 安装必要的依赖..."
            $SUDO_CMD apt install -y apt-transport-https ca-certificates curl software-properties-common gnupg lsb-release
            
            echo "🔑 添加Docker官方GPG密钥..."
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | $SUDO_CMD gpg --dearmor -o /usr/share/keyrings/docker.gpg
            
            echo "📋 添加Docker软件源..."
            echo \
              "deb [arch=amd64 signed-by=/usr/share/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | \
              $SUDO_CMD tee /etc/apt/sources.list.d/docker.list > /dev/null
            
            echo "🔄 更新软件包列表..."
            $SUDO_CMD apt update
            
            echo "📥 安装Docker CE..."
            $SUDO_CMD apt install -y docker-ce docker-ce-cli containerd.io
            
            echo "🚀 启动Docker服务..."
            $SUDO_CMD systemctl enable --now docker
            
            echo "👥 添加用户到docker组..."
            $SUDO_CMD usermod -aG docker $USER
            ;;
        "yum")
            echo "📦 安装必要的依赖..."
            $SUDO_CMD yum install -y yum-utils
            
            echo "📋 添加Docker软件源..."
            $SUDO_CMD yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
            
            echo "📥 安装Docker CE..."
            $SUDO_CMD yum install -y docker-ce docker-ce-cli containerd.io
            
            echo "🚀 启动Docker服务..."
            $SUDO_CMD systemctl enable --now docker
            
            echo "👥 添加用户到docker组..."
            $SUDO_CMD usermod -aG docker $USER
            ;;
        "dnf")
            echo "📦 安装必要的依赖..."
            $SUDO_CMD dnf install -y dnf-plugins-core
            
            echo "📋 添加Docker软件源..."
            $SUDO_CMD dnf config-manager --add-repo https://download.docker.com/linux/fedora/docker-ce.repo
            
            echo "📥 安装Docker CE..."
            $SUDO_CMD dnf install -y docker-ce docker-ce-cli containerd.io
            
            echo "🚀 启动Docker服务..."
            $SUDO_CMD systemctl enable --now docker
            
            echo "👥 添加用户到docker组..."
            $SUDO_CMD usermod -aG docker $USER
            ;;
        *)
            echo "❌ 不支持的包管理器，请手动安装Docker"
            echo "📖 Ubuntu/Debian用户请运行以下命令："
            echo "sudo apt update"
            echo "sudo apt install -y apt-transport-https ca-certificates curl software-properties-common gnupg lsb-release"
            echo "curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker.gpg"
            echo "echo \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \$(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null"
            echo "sudo apt update"
            echo "sudo apt install -y docker-ce docker-ce-cli containerd.io"
            echo "sudo systemctl enable --now docker"
            echo "sudo usermod -aG docker \$USER"
            return 1
            ;;
    esac
    
    # 验证安装
    echo "🔍 验证Docker安装..."
    if command -v docker >/dev/null 2>&1; then
        echo "✅ Docker 安装完成"
        echo "📊 Docker版本: $(docker --version)"
        echo ""
        echo "⚠️ 重要提示:"
        echo "• 请重新登录或运行 'newgrp docker' 以使用户组生效"
        echo "• 或者退出当前终端并重新连接"
        echo "• 然后重新运行脚本选择容器模式"
        return 0
    else
        echo "❌ Docker安装失败"
        return 1
    fi
}

# 创建Nexus节点容器
create_container() {
    local container_name="$1"
    local node_id="$2"
    
    echo "🐳 创建容器: $container_name (节点ID: $node_id)"
    
    # 创建容器，使用ubuntu作为基础镜像
    docker run -d \
        --name "$container_name" \
        --restart unless-stopped \
        ubuntu:22.04 \
        bash -c "
            # 更新包管理器
            apt update && apt install -y curl build-essential protobuf-compiler
            
            # 安装Rust
            curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
            source ~/.cargo/env
            rustup default stable
            
            # 安装nexus-cli
            curl https://cli.nexus.xyz | sh
            export PATH=\"\$HOME/.nexus/bin:\$PATH\"
            
            # 启动节点
            echo '=== Nexus 节点运行中 (Docker) ==='
            echo '节点ID: $node_id'
            echo '容器名称: $container_name'
            echo '开始时间: '\$(date)
            echo '环境: Docker Container'
            echo ''
            
            while true; do
                echo \"\$(date): 启动节点 $node_id\"
                ~/.nexus/bin/nexus-network start --node-id \"$node_id\" || {
                    echo \"节点启动失败，5秒后重试...\"
                    sleep 5
                    continue
                }
                sleep 1
            done
        "
    
    if [ $? -eq 0 ]; then
        echo "✅ 容器 $container_name 创建成功"
        return 0
    else
        echo "❌ 容器 $container_name 创建失败"
        return 1
    fi
}

# 检查容器状态
check_container_status() {
    echo "📊 检查容器状态..."
    echo ""
    
    nexus_containers=$(docker ps --format "table {{.Names}}\t{{.Status}}" | grep nexus_ || echo "")
    
    if [ -z "$nexus_containers" ]; then
        echo "❌ 没有发现运行中的 Nexus 容器"
        return
    fi
    
    echo "✅ 运行中的节点容器:"
    echo ""
    echo "$nexus_containers"
    echo ""
    
    count=$(docker ps | grep nexus_ | wc -l)
    echo "总计: $count 个容器运行中"
}

# 停止容器
stop_container() {
    local container_name="$1"
    
    if docker ps | grep -q "$container_name"; then
        echo "🛑 停止容器: $container_name"
        docker stop "$container_name" >/dev/null 2>&1
        docker rm "$container_name" >/dev/null 2>&1
        echo "✅ 容器 $container_name 已停止并删除"
    else
        echo "❌ 容器 $container_name 未找到或未运行"
    fi
}

# 连接到容器
connect_to_container() {
    local container_name="$1"
    
    if docker ps | grep -q "$container_name"; then
        echo "🔗 连接到容器 $container_name..."
        echo "提示: 输入 'exit' 退出容器"
        docker exec -it "$container_name" bash
    else
        echo "❌ 容器 $container_name 未找到或未运行"
    fi
}

# 查看容器日志
show_container_logs() {
    local container_name="$1"
    
    if docker ps -a | grep -q "$container_name"; then
        echo "📄 显示容器日志: $container_name"
        docker logs -f "$container_name"
    else
        echo "❌ 容器 $container_name 未找到"
    fi
}

# 根据环境调整命令
get_package_manager() {
    if command -v apt >/dev/null 2>&1; then
        echo "apt"
    elif command -v yum >/dev/null 2>&1; then
        echo "yum"
    elif command -v dnf >/dev/null 2>&1; then
        echo "dnf"
    elif command -v pacman >/dev/null 2>&1; then
        echo "pacman"
    else
        echo "unknown"
    fi
}

# 检查sudo权限
check_sudo() {
    if [[ $EUID -eq 0 ]]; then
        SUDO_CMD=""
        echo "✅ 当前为root用户"
    elif sudo -n true 2>/dev/null; then
        SUDO_CMD="sudo"
        echo "✅ sudo权限可用"
    else
        echo "⚠️ 需要sudo权限来安装系统依赖"
        echo "请确保当前用户有sudo权限，或以root用户运行"
        SUDO_CMD="sudo"
    fi
}

# 显示主要banner
show_main_banner() {
    echo "
██╗  ██╗██╗ █████╗  ██████╗ ██╗     ██╗███╗   ██╗
╚██╗██╔╝██║██╔══██╗██╔═══██╗██║     ██║████╗  ██║
 ╚███╔╝ ██║███████║██║   ██║██║     ██║██╔██╗ ██║
 ██╔██╗ ██║██╔══██║██║   ██║██║     ██║██║╚██╗██║
██╔╝ ██╗██║██║  ██║╚██████╔╝███████╗██║██║ ╚████║
╚═╝  ╚═╝╚═╝╚═╝  ╚═╝ ╚═════╝ ╚══════╝╚═╝╚═╝  ╚═══╝

    === Nexus Network 一体化管理工具 ===
    支持 Linux 和 Windows WSL 环境
    智能会话管理 (tmux/screen/docker)
** ====================================== **
*         此脚本仅供免费使用              *
*         禁止出售或用于盈利              *
** ====================================== **

* 作者: @YOYOMYOYOA
* 空投玩家 | 现货玩家 | meme收藏
* Github: github.com/mumumusf

** ====================================== **
*            免责声明                      *
* 此脚本仅供学习交流使用                  *
* 使用本脚本所产生的任何后果由用户自行承担 *
* 如果因使用本脚本造成任何损失，作者概不负责*
** ====================================== **
"
}

# 内存检测函数
detect_memory() {
    echo "🔍 正在检测系统内存..."
    
    # 获取总内存（单位：GB）
    if [[ -f /proc/meminfo ]]; then
        total_memory_kb=$(grep MemTotal /proc/meminfo | awk '{print $2}')
        total_memory_gb=$((total_memory_kb / 1024 / 1024))
        
        # 获取可用内存（单位：GB）
        available_memory_kb=$(grep MemAvailable /proc/meminfo | awk '{print $2}')
        available_memory_gb=$((available_memory_kb / 1024 / 1024))
    else
        echo "❌ 无法读取内存信息，使用默认配置"
        total_memory_gb=8
        available_memory_gb=6
    fi
    
    echo "💾 系统总内存: ${total_memory_gb}GB"
    echo "💿 可用内存: ${available_memory_gb}GB"
    
    # 根据内存计算推荐节点数（每个节点建议4GB，但保留2GB给系统）
    if [ $total_memory_gb -ge 6 ]; then
        recommended_nodes=$(((total_memory_gb - 2) / 4))
        if [ $recommended_nodes -lt 1 ]; then
            recommended_nodes=1
        fi
    else
        recommended_nodes=1
    fi
    
    echo "🎯 推荐节点数量: ${recommended_nodes} 个节点"
    echo "📊 内存分配策略: 每节点4GB，系统保留2GB"
    echo ""
    
    return $recommended_nodes
}

# 安装系统依赖
install_system_dependencies() {
    echo "📦 安装系统依赖..."
    
    PKG_MANAGER=$(get_package_manager)
    
    case $PKG_MANAGER in
        "apt")
            echo "🔄 更新软件包列表..."
            $SUDO_CMD apt update
            echo "📥 安装依赖包..."
            $SUDO_CMD apt install -y protobuf-compiler curl build-essential
            ;;
        "yum")
            echo "📥 安装依赖包..."
            $SUDO_CMD yum install -y protobuf-compiler curl gcc gcc-c++ make
            ;;
        "dnf")
            echo "📥 安装依赖包..."
            $SUDO_CMD dnf install -y protobuf-compiler curl gcc gcc-c++ make
            ;;
        "pacman")
            echo "🔄 更新软件包列表..."
            $SUDO_CMD pacman -Sy
            echo "📥 安装依赖包..."
            $SUDO_CMD pacman -S --noconfirm protobuf curl base-devel
            ;;
        *)
            echo "❌ 未知的包管理器，请手动安装以下依赖："
            echo "  - protobuf-compiler"
            echo "  - curl"
            echo "  - build-essential (或等效的编译工具)"
            return 1
            ;;
    esac
    
    echo "✅ 系统依赖安装完成"
    return 0
}

# 安装会话管理器
install_session_manager() {
    if [[ "$SESSION_MANAGER" == "tmux" ]]; then
        if ! command -v tmux &> /dev/null; then
            echo "📺 正在安装 tmux (适用于WSL)..."
            
            PKG_MANAGER=$(get_package_manager)
            
            case $PKG_MANAGER in
                "apt")
                    $SUDO_CMD apt install -y tmux
                    ;;
                "yum")
                    $SUDO_CMD yum install -y tmux
                    ;;
                "dnf")
                    $SUDO_CMD dnf install -y tmux
                    ;;
                "pacman")
                    $SUDO_CMD pacman -S --noconfirm tmux
                    ;;
                *)
                    echo "❌ 无法自动安装tmux，请手动安装"
                    return 1
                    ;;
            esac
            
            echo "✅ tmux 安装完成！"
        else
            echo "✅ tmux 已安装"
        fi
    else
        if ! command -v screen &> /dev/null; then
            echo "📺 正在安装 screen (适用于Linux)..."
            
            PKG_MANAGER=$(get_package_manager)
            
            case $PKG_MANAGER in
                "apt")
                    $SUDO_CMD apt install -y screen
                    ;;
                "yum")
                    $SUDO_CMD yum install -y screen
                    ;;
                "dnf")
                    $SUDO_CMD dnf install -y screen
                    ;;
                "pacman")
                    $SUDO_CMD pacman -S --noconfirm screen
                    ;;
                *)
                    echo "❌ 无法自动安装screen，请手动安装"
                    return 1
                    ;;
            esac
            
            echo "✅ screen 安装完成！"
        else
            echo "✅ screen 已安装"
        fi
    fi
    
    return 0
}

# 创建会话（根据环境使用不同的会话管理器）
create_session() {
    local session_name="$1"
    local node_id="$2"
    local session_index="$3"
    local total_sessions="$4"
    
    if [[ "$SESSION_MANAGER" == "tmux" ]]; then
        # 使用tmux创建会话
        tmux new-session -d -s "$session_name" bash -c "
    export PATH=\"\$HOME/.nexus/bin:\$PATH\"
    echo '=== Nexus 节点运行中 (tmux) ==='
    echo '节点ID: $node_id'
    echo '会话名称: $session_name'
    echo '节点序号: $session_index/$total_sessions'
    echo '开始时间: \$(date)'
    echo '内存分配: 4GB (推荐)'
    echo '环境: $ENVIRONMENT'
    echo ''

    echo \"\$(date): 启动节点 $node_id\"
    nexus-network start --node-id \"$node_id\"
    "
    else
        # 使用screen创建会话
        screen -dmS "$session_name" bash -c "
    export PATH=\"\$HOME/.nexus/bin:\$PATH\"
    echo '=== Nexus 节点运行中 (screen) ==='
    echo '节点ID: $node_id'
    echo '会话名称: $session_name'
    echo '节点序号: $session_index/$total_sessions'
    echo '开始时间: \$(date)'
    echo '内存分配: 4GB (推荐)'
    echo '环境: $ENVIRONMENT'
    echo ''

    echo \"\$(date): 启动节点 $node_id\"
    nexus-network start --node-id \"$node_id\"
    "
    fi
}

# 列出会话
list_sessions() {
    if [[ "$SESSION_MANAGER" == "tmux" ]]; then
        tmux list-sessions 2>/dev/null | grep nexus_ || echo ""
    else
        screen -list 2>/dev/null | grep nexus_ || echo ""
    fi
}

# 连接到会话
connect_to_session() {
    local session_name="$1"
    
    if [[ "$SESSION_MANAGER" == "tmux" ]]; then
        echo "🔗 连接到tmux会话 $session_name..."
        echo "提示: 按 Ctrl+B 然后 D 分离会话"
        tmux attach-session -t "$session_name"
    else
        echo "🔗 连接到screen会话 $session_name..."
        echo "提示: 按 Ctrl+A 然后 D 分离会话"
        screen -r "$session_name"
    fi
}

# 停止会话
kill_session() {
    local session_name="$1"
    
    if [[ "$SESSION_MANAGER" == "tmux" ]]; then
        tmux kill-session -t "$session_name" 2>/dev/null
    else
        screen -S "$session_name" -X quit 2>/dev/null
    fi
}

# 检查会话是否存在
session_exists() {
    local session_name="$1"
    
    if [[ "$SESSION_MANAGER" == "tmux" ]]; then
        tmux list-sessions 2>/dev/null | grep -q "^$session_name:"
    else
        screen -list 2>/dev/null | grep -q "$session_name"
    fi
}

# 安装节点功能
install_nodes() {
    echo "
    === Nexus 自动化安装工具 (多开版) ===
"
    
    # 检测环境
    detect_environment
    
    # 检查sudo权限
    check_sudo
    
    # 询问运行模式
    echo "🚀 选择运行模式:"
    echo "1. 容器模式 (推荐) - 使用Docker容器运行节点"
    echo "2. 会话模式 - 使用 $SESSION_MANAGER 运行节点"
    echo ""
    read -p "请选择运行模式 (1/2): " run_mode
    
    if [[ "$run_mode" == "1" ]]; then
        USE_CONTAINER="true"
        echo "✅ 选择容器模式"
        
        # 检查Docker
        if ! check_docker; then
            read -p "是否安装Docker？(y/n): " install_docker_choice
            if [[ "$install_docker_choice" == "y" || "$install_docker_choice" == "Y" ]]; then
                if ! install_docker; then
                    echo "❌ Docker安装失败，切换到会话模式"
                    USE_CONTAINER="false"
                fi
            else
                echo "❌ 需要Docker运行容器模式，切换到会话模式"
                USE_CONTAINER="false"
            fi
        fi
    else
        USE_CONTAINER="false"
        echo "✅ 选择会话模式 ($SESSION_MANAGER)"
    fi
    
    # 检测系统内存
    detect_memory
    recommended_nodes=$?

    # 安装会话管理器（仅会话模式需要）
    if [[ "$USE_CONTAINER" == "false" ]]; then
        if ! install_session_manager; then
            return 1
        fi
    fi

    # 安装系统依赖
    if ! install_system_dependencies; then
        return 1
    fi

    # 安装 Rust
    echo "🦀 安装 Rust..."
    if ! command -v rustc &> /dev/null; then
        curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
        source $HOME/.cargo/env
        echo "✅ Rust 安装完成"
    else
        echo "✅ Rust 已安装"
        source $HOME/.cargo/env 2>/dev/null || true
    fi

    # 设置 Rust 默认版本
    echo "⚙️ 设置 Rust 默认版本..."
    rustup default stable
    echo "✅ Rust 默认版本设置完成"

    # 安装 nexus-cli
    echo "📥 安装 nexus-cli..."
    echo "注意：如果出现条款确认提示，请输入 'y' 确认"
    curl https://cli.nexus.xyz | sh
    echo "✅ nexus-cli 安装完成"

    # 添加 PATH 环境变量
    echo "🔧 配置环境变量..."
    
    # 检测使用的shell
    if [[ $SHELL == *"zsh"* ]]; then
        SHELL_RC="$HOME/.zshrc"
    else
        SHELL_RC="$HOME/.bashrc"
    fi
    
    # 检查是否已添加PATH
    if ! grep -q ".nexus/bin" $SHELL_RC 2>/dev/null; then
        echo 'export PATH="$HOME/.nexus/bin:$PATH"' >> $SHELL_RC
        echo "✅ 已添加到 $SHELL_RC"
    else
        echo "✅ PATH 已配置"
    fi
    
    source $SHELL_RC 2>/dev/null || source ~/.bashrc 2>/dev/null || true
    export PATH="$HOME/.nexus/bin:$PATH"
    echo "✅ 环境变量配置完成"

    echo "🎉 nexus-cli 及其依赖安装完成！"

    # 询问用户是否要建立会话
    echo ""
    echo "=== 安装完成 ==="
    echo "nexus-cli 已准备就绪！"
    echo ""
    if [[ "$USE_CONTAINER" == "true" ]]; then
        read -p "是否要创建 Docker 容器运行节点？(y/n): " create_session
    else
        read -p "是否要建立 $SESSION_MANAGER 会话运行节点？(y/n): " create_session
    fi

    if [[ $create_session != "y" && $create_session != "Y" ]]; then
        echo "好的，您可以稍后手动运行节点。"
        echo "手动运行命令：nexus-network start --node-id <您的节点ID>"
        return 0
    fi

    # 获取节点数量和ID
    echo ""
    echo "=== 多开节点配置 ==="
    echo "🎯 系统推荐运行 ${recommended_nodes} 个节点"
    echo ""
    read -p "请输入要运行的节点数量 (1-${recommended_nodes}): " node_count

    # 验证节点数量
    if ! [[ "$node_count" =~ ^[0-9]+$ ]] || [ "$node_count" -lt 1 ] || [ "$node_count" -gt "$recommended_nodes" ]; then
        echo "❌ 错误：节点数量必须是 1-${recommended_nodes} 之间的数字"
        echo "根据您的内存配置，建议不要超过推荐数量"
        return 1
    fi

    echo "✅ 将运行 ${node_count} 个节点"
    echo ""

    # 获取节点ID列表
    declare -a NODE_IDS
    echo "请依次输入 ${node_count} 个节点ID（纯数字）:"

    for ((i=1; i<=node_count; i++)); do
        while true; do
            read -p "节点 $i ID: " node_id
            
            # 清理输入（去除空格和特殊字符）
            node_id=$(echo "$node_id" | tr -d '[:space:]')
            
            # 验证节点ID
            if [ -z "$node_id" ]; then
                echo "❌ 错误：节点ID不能为空，请重新输入"
                continue
            fi
            
            # 检查是否只包含数字
            if ! [[ "$node_id" =~ ^[0-9]+$ ]]; then
                echo "❌ 错误：节点ID应该只包含数字，请重新输入"
                continue
            fi
            
            # 检查是否重复
            duplicate=false
            for existing_id in "${NODE_IDS[@]}"; do
                if [ "$existing_id" = "$node_id" ]; then
                    echo "❌ 错误：节点ID $node_id 已存在，请输入不同的ID"
                    duplicate=true
                    break
                fi
            done
            
            if [ "$duplicate" = false ]; then
                NODE_IDS+=("$node_id")
                echo "✅ 节点 $i ID验证通过: $node_id"
                break
            fi
        done
    done

    echo ""
    echo "📋 节点配置摘要:"
    for ((i=0; i<${#NODE_IDS[@]}; i++)); do
        echo "  节点 $((i+1)): ${NODE_IDS[$i]}"
    done

    # 检查现有会话/容器并启动多个节点
    echo ""
    if [[ "$USE_CONTAINER" == "true" ]]; then
        echo "=== 启动多个节点 (Docker容器) ==="
    else
        echo "=== 启动多个节点 ($SESSION_MANAGER) ==="
    fi

    # 检查是否有冲突的会话/容器
    conflicting_items=()
    for node_id in "${NODE_IDS[@]}"; do
        item_name="nexus_${node_id}"
        if [[ "$USE_CONTAINER" == "true" ]]; then
            if docker ps -a | grep -q "$item_name"; then
                conflicting_items+=("$item_name")
            fi
        else
            if session_exists "$item_name"; then
                conflicting_items+=("$item_name")
            fi
        fi
    done

    # 处理冲突
    if [ ${#conflicting_items[@]} -gt 0 ]; then
        if [[ "$USE_CONTAINER" == "true" ]]; then
            echo "⚠️ 发现已存在的容器:"
        else
            echo "⚠️ 发现已存在的会话:"
        fi
        for item in "${conflicting_items[@]}"; do
            echo "  - $item"
        done
        echo ""
        if [[ "$USE_CONTAINER" == "true" ]]; then
            read -p "是否要停止现有容器并创建新容器？(y/n): " choice
        else
            read -p "是否要终止现有会话并创建新会话？(y/n): " choice
        fi
        if [[ $choice == "y" || $choice == "Y" ]]; then
            for item in "${conflicting_items[@]}"; do
                if [[ "$USE_CONTAINER" == "true" ]]; then
                    echo "🗑️ 停止容器: $item"
                    stop_container "$item"
                else
                    echo "🗑️ 终止会话: $item"
                    kill_session "$item"
                fi
            done
        else
            echo "❌ 操作取消"
            return 0
        fi
    fi

    # 启动所有节点
    echo "🚀 开始启动 ${#NODE_IDS[@]} 个节点..."
    echo ""

    # 创建启动脚本
    for ((i=0; i<${#NODE_IDS[@]}; i++)); do
        node_id="${NODE_IDS[$i]}"
        item_name="nexus_${node_id}"
        
        echo "📡 启动节点 $((i+1))/${#NODE_IDS[@]}: $node_id"
        
        if [[ "$USE_CONTAINER" == "true" ]]; then
            # 创建容器
            create_container "$item_name" "$node_id"
            echo "✅ 节点 $node_id 已在 Docker 容器中启动！"
        else
            # 创建会话
            create_session "$item_name" "$node_id" "$((i+1))" "${#NODE_IDS[@]}"
            echo "✅ 节点 $node_id 已在 $SESSION_MANAGER 会话中启动！"
        fi
        
        # 添加启动间隔，避免同时启动造成资源冲突
        if [ $((i+1)) -lt ${#NODE_IDS[@]} ]; then
            echo "⏳ 等待3秒后启动下一个节点..."
            sleep 3
        fi
    done

    echo ""
    echo "🎉 所有节点启动完成！"
    echo ""
    echo "📋 节点管理命令："
    if [[ "$USE_CONTAINER" == "true" ]]; then
        echo "• 查看所有容器: docker ps | grep nexus_"
        echo "• 连接到指定节点: docker exec -it nexus_<节点ID> bash"
        echo "• 查看节点日志: docker logs -f nexus_<节点ID>"
        echo "• 停止指定节点: docker stop nexus_<节点ID> && docker rm nexus_<节点ID>"
    elif [[ "$SESSION_MANAGER" == "tmux" ]]; then
        echo "• 查看所有会话: tmux list-sessions"
        echo "• 连接到指定节点: tmux attach-session -t nexus_<节点ID>"
        echo "• 分离会话: 在会话中按 Ctrl+B 然后按 D"
        echo "• 停止指定节点: tmux kill-session -t nexus_<节点ID>"
    else
        echo "• 查看所有会话: screen -list"
        echo "• 连接到指定节点: screen -r nexus_<节点ID>"
        echo "• 分离会话: 在会话中按 Ctrl+A 然后按 D"
        echo "• 停止指定节点: screen -S nexus_<节点ID> -X quit"
    fi
    echo "• 使用管理工具: bash yoyom"
    echo ""

    # 创建停止所有节点的脚本
    if [[ "$USE_CONTAINER" == "true" ]]; then
        cat > stop_all_nodes.sh << 'EOF'
#!/bin/bash
echo "🛑 停止所有 Nexus 节点 (Docker)..."
for container in $(docker ps | grep nexus_ | awk '{print $NF}'); do
    echo "停止容器: $container"
    docker stop "$container" >/dev/null 2>&1
    docker rm "$container" >/dev/null 2>&1
done
echo "✅ 所有节点已停止"
EOF
    elif [[ "$SESSION_MANAGER" == "tmux" ]]; then
        cat > stop_all_nodes.sh << 'EOF'
#!/bin/bash
echo "🛑 停止所有 Nexus 节点 (tmux)..."
for session in $(tmux list-sessions 2>/dev/null | grep nexus_ | cut -d: -f1); do
    echo "停止会话: $session"
    tmux kill-session -t "$session" 2>/dev/null
done
echo "✅ 所有节点已停止"
EOF
    else
        cat > stop_all_nodes.sh << 'EOF'
#!/bin/bash
echo "🛑 停止所有 Nexus 节点 (screen)..."
for session in $(screen -list 2>/dev/null | grep nexus_ | awk '{print $1}'); do
    echo "停止会话: $session"
    screen -S "$session" -X quit 2>/dev/null
done
echo "✅ 所有节点已停止"
EOF
    fi

    chmod +x stop_all_nodes.sh 2>/dev/null || true

    echo "📊 当前运行的节点:"
    for node_id in "${NODE_IDS[@]}"; do
        if [[ "$USE_CONTAINER" == "true" ]]; then
            echo "  - 节点 $node_id: docker exec -it nexus_$node_id bash"
        elif [[ "$SESSION_MANAGER" == "tmux" ]]; then
            echo "  - 节点 $node_id: tmux attach-session -t nexus_$node_id"
        else
            echo "  - 节点 $node_id: screen -r nexus_$node_id"
        fi
    done

    echo ""
    echo "🌐 现在您可以安全地关闭SSH连接，所有节点会继续运行！"
    echo "📝 已创建 stop_all_nodes.sh 脚本用于一键停止所有节点"
    echo "🛠️ 运行 'bash yoyom' 进入节点管理界面"
}

# ===== 节点管理功能 =====

# 检查节点状态
check_nodes_status() {
    echo "📊 检查节点状态..."
    echo ""
    
    # 确保环境检测已运行
    if [[ -z "$SESSION_MANAGER" ]]; then
        detect_environment >/dev/null 2>&1
    fi
    
    # 检测是否有Docker容器运行
    nexus_containers=$(docker ps 2>/dev/null | grep nexus_ | awk '{print $NF}' || echo "")
    
    if [[ -n "$nexus_containers" ]]; then
        USE_CONTAINER="true"
        echo "✅ 运行中的节点容器 (Docker):"
        echo ""
        
        count=1
        for container in $nexus_containers; do
            node_id=$(echo "$container" | sed 's/nexus_//')
            status=$(docker ps --format "table {{.Status}}" | tail -n +2 | sed -n "${count}p")
            echo "  $count. 节点ID: $node_id"
            echo "     容器名: $container"
            echo "     状态: $status"
            echo "     连接命令: docker exec -it $container bash"
            echo "     查看日志: docker logs -f $container"
            echo ""
            ((count++))
        done
        
        echo "总计: $((count-1)) 个容器运行中"
        return
    fi
    
    # 检查会话管理器
    if [[ "$SESSION_MANAGER" == "tmux" ]]; then
        nexus_sessions=$(tmux list-sessions 2>/dev/null | grep nexus_ | cut -d: -f1)
    else
        nexus_sessions=$(screen -list 2>/dev/null | grep nexus_ | awk '{print $1}')
    fi
    
    if [ -z "$nexus_sessions" ]; then
        echo "❌ 没有发现运行中的 Nexus 节点"
        return
    fi
    
    echo "✅ 运行中的节点 ($SESSION_MANAGER):"
    echo ""
    
    count=1
    for session in $nexus_sessions; do
        if [[ "$SESSION_MANAGER" == "tmux" ]]; then
            node_id=$(echo "$session" | sed 's/nexus_//')
            echo "  $count. 节点ID: $node_id"
            echo "     会话名: $session"
            echo "     连接命令: tmux attach-session -t $session"
        else
            node_id=$(echo "$session" | sed 's/.*nexus_//' | sed 's/\..*$//')
            echo "  $count. 节点ID: $node_id"
            echo "     会话名: $session"
            echo "     连接命令: screen -r $session"
        fi
        echo ""
        ((count++))
    done
    
    echo "总计: $((count-1)) 个节点运行中"
}

# 停止指定节点
stop_node() {
    read -p "请输入要停止的节点ID: " node_id
    
    if [ -z "$node_id" ]; then
        echo "❌ 节点ID不能为空"
        return
    fi
    
    item_name="nexus_${node_id}"
    
    # 检查是否有容器运行
    if docker ps 2>/dev/null | grep -q "$item_name"; then
        echo "🛑 停止容器 $node_id..."
        stop_container "$item_name"
        echo "✅ 节点 $node_id 已停止"
    elif session_exists "$item_name"; then
        echo "🛑 停止节点 $node_id..."
        kill_session "$item_name"
        echo "✅ 节点 $node_id 已停止"
    else
        echo "❌ 未找到节点 $node_id 的运行容器或会话"
    fi
}

# 停止所有节点
stop_all_nodes() {
    echo "🛑 停止所有 Nexus 节点..."
    
    # 检查容器
    nexus_containers=$(docker ps 2>/dev/null | grep nexus_ | awk '{print $NF}' || echo "")
    
    if [[ -n "$nexus_containers" ]]; then
        echo "停止Docker容器..."
        for container in $nexus_containers; do
            node_id=$(echo "$container" | sed 's/nexus_//')
            echo "停止容器节点: $node_id"
            docker stop "$container" >/dev/null 2>&1
            docker rm "$container" >/dev/null 2>&1
        done
        echo "✅ 所有容器节点已停止"
        return
    fi
    
    # 确保环境检测已运行
    if [[ -z "$SESSION_MANAGER" ]]; then
        detect_environment >/dev/null 2>&1
    fi
    
    if [[ "$SESSION_MANAGER" == "tmux" ]]; then
        nexus_sessions=$(tmux list-sessions 2>/dev/null | grep nexus_ | cut -d: -f1)
    else
        nexus_sessions=$(screen -list 2>/dev/null | grep nexus_ | awk '{print $1}')
    fi
    
    if [ -z "$nexus_sessions" ]; then
        echo "❌ 没有发现运行中的 Nexus 节点"
        return
    fi
    
    for session in $nexus_sessions; do
        if [[ "$SESSION_MANAGER" == "tmux" ]]; then
            node_id=$(echo "$session" | sed 's/nexus_//')
            echo "停止节点: $node_id"
            tmux kill-session -t "$session" 2>/dev/null
        else
            node_id=$(echo "$session" | sed 's/.*nexus_//' | sed 's/\..*$//')
            echo "停止节点: $node_id"
            screen -S "$session" -X quit 2>/dev/null
        fi
    done
    
    echo "✅ 所有节点已停止"
}

# 连接到指定节点
connect_to_node() {
    check_nodes_status
    
    # 检查是否有容器或会话运行
    container_count=$(docker ps 2>/dev/null | grep nexus_ | wc -l || echo "0")
    
    # 确保环境检测已运行
    if [[ -z "$SESSION_MANAGER" ]]; then
        detect_environment >/dev/null 2>&1
    fi
    
    if [[ "$SESSION_MANAGER" == "tmux" ]]; then
        session_count=$(tmux list-sessions 2>/dev/null | grep nexus_ | wc -l)
    else
        session_count=$(screen -list 2>/dev/null | grep nexus_ | wc -l)
    fi
    
    if [ "$container_count" -eq 0 ] && [ "$session_count" -eq 0 ]; then
        return
    fi
    
    read -p "请输入要连接的节点ID: " node_id
    
    if [ -z "$node_id" ]; then
        echo "❌ 节点ID不能为空"
        return
    fi
    
    item_name="nexus_${node_id}"
    
    # 优先连接容器
    if docker ps 2>/dev/null | grep -q "$item_name"; then
        connect_to_container "$item_name"
    elif session_exists "$item_name"; then
        connect_to_session "$item_name"
    else
        echo "❌ 未找到节点 $node_id 的运行容器或会话"
    fi
}

# 显示系统资源使用情况
show_system_resources() {
    echo "💻 系统资源使用情况:"
    echo ""
    
    # 检测环境
    if [[ -z "$SESSION_MANAGER" ]]; then
        detect_environment
    fi
    
    # 内存使用情况
    if [[ -f /proc/meminfo ]]; then
        total_memory_kb=$(grep MemTotal /proc/meminfo | awk '{print $2}')
        available_memory_kb=$(grep MemAvailable /proc/meminfo | awk '{print $2}')
        used_memory_kb=$((total_memory_kb - available_memory_kb))
        
        total_memory_gb=$((total_memory_kb / 1024 / 1024))
        used_memory_gb=$((used_memory_kb / 1024 / 1024))
        available_memory_gb=$((available_memory_kb / 1024 / 1024))
        
        memory_usage_percent=$((used_memory_gb * 100 / total_memory_gb))
        
        echo "📊 内存使用:"
        echo "  总内存: ${total_memory_gb}GB"
        echo "  已使用: ${used_memory_gb}GB (${memory_usage_percent}%)"
        echo "  可用内存: ${available_memory_gb}GB"
    else
        echo "❌ 无法读取内存信息"
    fi
    echo ""
    
    # CPU使用情况
    if command -v top >/dev/null 2>&1; then
        cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | sed 's/%us,//' 2>/dev/null || echo "N/A")
        echo "🖥️ CPU使用率: ${cpu_usage}%"
    else
        echo "🖥️ CPU使用率: 无法获取"
    fi
    echo ""
    
    # 磁盘使用情况
    echo "💾 磁盘使用:"
    if command -v df >/dev/null 2>&1; then
        df -h / 2>/dev/null | tail -1 | awk '{print "  根目录: " $3 "/" $2 " (" $5 " 已使用)")' || echo "  无法获取磁盘信息"
    else
        echo "  无法获取磁盘信息"
    fi
    echo ""
    
    # 运行中的节点数量
    container_count=$(docker ps 2>/dev/null | grep nexus_ | wc -l || echo "0")
    
    if [ "$container_count" -gt 0 ]; then
        echo "🚀 运行中的节点: ${container_count} 个 (Docker容器)"
        nexus_count=$container_count
    else
        if [[ "$SESSION_MANAGER" == "tmux" ]]; then
            nexus_count=$(tmux list-sessions 2>/dev/null | grep nexus_ | wc -l)
        else
            nexus_count=$(screen -list 2>/dev/null | grep nexus_ | wc -l)
        fi
        echo "🚀 运行中的节点: ${nexus_count} 个 ($SESSION_MANAGER)"
    fi
    
    if [ $nexus_count -gt 0 ]; then
        estimated_memory=$((nexus_count * 4))
        echo "📈 预估节点内存使用: ${estimated_memory}GB"
    fi
}

# 管理菜单
show_management_menu() {
    echo ""
    echo "============= 节点管理菜单 =============="
    echo "1. 📊 查看节点状态"
    echo "2. 🔗 连接到指定节点"
    echo "3. 🛑 停止指定节点"
    echo "4. 🚫 停止所有节点"
    echo "5. 💻 查看系统资源"
    echo "6. 📄 查看节点日志 (容器模式)"
    echo "7. 🔄 刷新菜单"
    echo "9. 🔙 返回主菜单"
    echo "0. 🚪 退出"
    echo "====================================="
    echo ""
}

# 节点管理主程序
manage_nodes() {
    echo "
    === Nexus 节点管理工具 ===
"
    
    # 检测环境
    if [[ -z "$SESSION_MANAGER" ]]; then
        detect_environment
    fi
    
    while true; do
        show_management_menu
        read -p "请选择操作 (0-7,9): " choice
        
        case $choice in
            1)
                check_nodes_status
                ;;
            2)
                connect_to_node
                ;;
            3)
                stop_node
                ;;
            4)
                read -p "确认停止所有节点？(y/n): " confirm
                if [[ $confirm == "y" || $confirm == "Y" ]]; then
                    stop_all_nodes
                fi
                ;;
            5)
                show_system_resources
                ;;
            6)
                # 查看节点日志（仅容器模式）
                if docker ps 2>/dev/null | grep nexus_ >/dev/null; then
                    read -p "请输入要查看日志的节点ID: " node_id
                    if [ -n "$node_id" ]; then
                        container_name="nexus_${node_id}"
                        if docker ps | grep -q "$container_name"; then
                            show_container_logs "$container_name"
                        else
                            echo "❌ 未找到节点 $node_id 的容器"
                        fi
                    fi
                else
                    echo "❌ 当前没有运行的容器，此功能仅适用于容器模式"
                fi
                ;;
            7)
                clear
                show_main_banner
                echo "
    === Nexus 节点管理工具 ===
"
                ;;
            9)
                return 0
                ;;
            0)
                echo "👋 再见！"
                exit 0
                ;;
            *)
                echo "❌ 无效选择，请输入 0-7 或 9"
                ;;
        esac
        
        echo ""
        read -p "按回车键继续..."
    done
}

# 主菜单
show_main_menu() {
    echo ""
    echo "=============== 主菜单 ==============="
    echo "1. 🚀 安装并启动 Nexus 节点"
    echo "2. 🛠️ 管理现有节点"
    echo "3. 💻 查看系统资源"
    echo "4. ℹ️ 显示帮助信息"
    echo "0. 🚪 退出"
    echo "===================================="
    echo ""
}

# 显示帮助信息
show_help() {
    echo "
📖 === Nexus Network 一体化管理工具帮助 ===

🌐 支持环境:
  • Linux (Ubuntu/CentOS/Debian/Arch Linux) - 使用 screen
  • Windows WSL (Windows Subsystem for Linux) - 使用 tmux
  • Docker 容器模式 (推荐) - 跨平台支持

🚀 主要功能:
  1. 智能环境检测和运行模式选择
  2. Docker容器模式 - 完全隔离的运行环境
  3. 自动检测系统内存并推荐节点数量
  4. 一键安装 nexus-cli 和相关依赖
  5. 支持多个节点同时运行
  6. 完整的节点管理功能
  7. 实时系统资源监控

📋 使用流程:
  1. 首次使用选择 '安装并启动 Nexus 节点'
  2. 按照提示输入节点数量和 ID
  3. 后续使用选择 '管理现有节点' 进行管理

🔧 常用命令:
  • 启动工具: bash yoyom
  
  容器模式 (Docker) [推荐]:
  • 查看所有容器: docker ps | grep nexus_
  • 连接到节点: docker exec -it nexus_<节点ID> bash
  • 查看节点日志: docker logs -f nexus_<节点ID>
  • 停止单个节点: docker stop nexus_<节点ID> && docker rm nexus_<节点ID>
  
  Linux环境 (screen):
  • 查看所有会话: screen -list
  • 连接到节点: screen -r nexus_<节点ID>
  • 分离会话: Ctrl+A 然后 D
  • 停止单个节点: screen -S nexus_<节点ID> -X quit
  
  WSL环境 (tmux):
  • 查看所有会话: tmux list-sessions
  • 连接到节点: tmux attach-session -t nexus_<节点ID>
  • 分离会话: Ctrl+B 然后 D
  • 停止单个节点: tmux kill-session -t nexus_<节点ID>
  
  通用:
  • 停止所有节点: bash stop_all_nodes.sh

💾 内存要求:
  • 每个节点需要 4GB 内存
  • 系统保留 2GB 内存
  • 例如: 10GB 内存可运行 2 个节点

❓ 获取节点ID:
  访问 https://nexus.xyz 注册并创建节点

⚠️ 注意事项:
  • 节点ID 必须是纯数字
  • 不要超过系统推荐的节点数量
  • SSH 断开后节点会继续运行
  • 推荐使用容器模式，稳定性更好
  • 容器模式需要Docker支持
  • WSL用户自动使用tmux，Linux用户使用screen

🔧 WSL环境说明:
  • 在Windows上需要先安装WSL
  • 推荐使用Ubuntu或Debian发行版
  • 确保WSL版本为WSL2
  • 脚本会自动检测并安装tmux

🐛 故障排除:
  • 如遇到Windows行结束符错误，运行: sed -i 's/\\r\$//' yoyom
  • WSL环境推荐使用容器模式或tmux
  • 如果会话无法创建，推荐使用容器模式
  • 容器启动失败：检查Docker是否正常运行
  • 权限问题：确保用户在docker组中: sudo usermod -aG docker $USER
"
}

# 主程序
main() {
    show_main_banner
    
    while true; do
        show_main_menu
        read -p "请选择操作 (0-4): " choice
        
        case $choice in
            1)
                install_nodes
                ;;
            2)
                manage_nodes
                ;;
            3)
                show_system_resources
                echo ""
                read -p "按回车键继续..."
                ;;
            4)
                show_help
                echo ""
                read -p "按回车键继续..."
                ;;
            0)
                echo "👋 感谢使用 Nexus Network 一体化管理工具！"
                exit 0
                ;;
            *)
                echo "❌ 无效选择，请输入 0-4"
                ;;
        esac
        
        echo ""
    done
}

# 检查参数并运行
if [ "$1" = "--install" ]; then
    # 直接安装模式
    show_main_banner
    install_nodes
elif [ "$1" = "--manage" ]; then
    # 直接管理模式
    show_main_banner
    manage_nodes
else
    # 交互模式
    main
fi 